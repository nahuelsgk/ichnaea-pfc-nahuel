<?php

namespace Ichnaea\Amqp\Mime;

/**
 * This class contains MIME/Multipart data
 *
 * The multipart contains a list of parts and it automatically
 * converts from and to base64.
 *
 * @author Miguel Ibero <miguel@ibero.me>
 * @see http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html
 */
class MimeMultipart implements \IteratorAggregate
{
    /**
     * Marker for the start of a boundary line
     *
     * @var string
     */
    const BoundaryMark = "--";

    /**
     * The end of line character for separating lines. Since the standard
     * is the windows end of line, also in unix software, we use that
     *
     * @var string
     */
    const EndOfLine = "\r\n";

    /**
     * The boundary marker of this multipart
     *
     * @var string
     */
    private $boundary;

    /**
     * The list of parts of this multipart. Each part is a MimePart object
     *
     * @see MimePart
     * @var array
     */
    private $parts = array();

    /**
     * Constructor. The boundary can be specified or else it will be autogenerated.
     *
     * @param string $boundary the boundary of this multipart
     */
    public function __construct($boundary=null)
    {
        if (!$boundary) {
            $boundary = uniqid();
        }
        $this->boundary = $boundary;
    }

    /**
     * Sets the boundary
     *
     * @param string $boundary the boundary
     */
    public function setBoundary($boundary)
    {
        $this->boundary = $boundary;
    }

    /**
     * Gets the boundary
     *
     * @return string the boundary
     */
    public function getBoundary()
    {
        return $this->boundary;
    }

    /**
     * Returns the entire parts array. Each element is a MimePart object
     *
     * @see MimePart
     * @return array the parts
     */
    public function getParts()
    {
        return $this->parts;
    }

    /**
     * Returns one MIME part or null if it does not exist
     *
     * @see MimePart
     * @param  integer  $n the part number
     * @return MimePart the part
     */
    public function getPart($n)
    {
        if (array_key_exists($n, $this->parts)) {
            return $this->parts[$n];
        }
    }

    /**
     * Returns the number of parts
     *
     * @return integer the number of parts
     */
    public function getNumParts()
    {
        return count($this->parts);
    }

    /**
     * Add a part
     *
     * @param MimePart the part to add
     */
    public function addPart($part)
    {
        if (is_string($part)) {
            $part = MimePart::fromString($part);
        }
        if (!$part instanceof MimePart) {
            throw new \InvalidArgumentException("part needs to be a MimePart object");
        }
        $this->parts[] = $part;
    }

    /**
     * Return an array iterator to the parts
     * so that the multipart can be used in fereach
     *
     * @see \IteratorAggregate
     * @return \ArrayIterator the iterator
     */
    public function getIterator()
    {
        return new \ArrayIterator($this->parts);
    }

    /**
     * Converts the object to a valid MIME multipart string
     *
     * @return string the MIME multipart data
     */
    public function __toString()
    {
        $str = "";
        foreach ($this->parts as $part) {
            $str .= self::BoundaryMark.$this->boundary.self::EndOfLine;
            $str .= $part.self::EndOfLine;
        }
        $str .= self::BoundaryMark.$this->boundary.self::BoundaryMark.self::EndOfLine;

        return $str;
    }

    /**
     * Loads the MIME multipart data into the object
     *
     * @param string $data the MIME multipart data
     */
    public static function fromString($data)
    {
        $multi = new MimeMultipart();
        $lines = explode(self::EndOfLine, $data);
        $part = "";
        $start = true;
        $n = strlen(self::BoundaryMark);
        foreach ($lines as $line) {
            if (substr($line, 0, $n) === self::BoundaryMark) {
                $boundary = substr($line, $n);
                if ($start) {
                    $multi->setBoundary($boundary);
                    $start = false;
                    continue;
                }
                if ($boundary === $multi->getBoundary().self::BoundaryMark) {
                    $multi->addPart(MimePart::fromString($part));
                    break;
                }
                if ($boundary === $multi->getBoundary()) {
                    $multi->addPart(MimePart::fromString($part));
                    $part = "";
                    continue;
                }
            }
            $part .= $line.self::EndOfLine;
        }

        return $multi;
    }
}
